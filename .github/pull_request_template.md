## 과제 체크포인트

### 기본과제

#### 목표 : 전역상태관리를 이용한 적절한 분리와 계층에 대한 이해를 통한 FSD 폴더 구조 적용하기

- 전역상태관리를 사용해서 상태를 분리하고 관리하는 방법에 대한 이해
- Context API, Jotai, Zustand 등 상태관리 라이브러리 사용하기
- FSD(Feature-Sliced Design)에 대한 이해
- FSD를 통한 관심사의 분리에 대한 이해
- 단일책임과 역할이란 무엇인가?
- 관심사를 하나만 가지고 있는가?
- 어디에 무엇을 넣어야 하는가?

#### 체크포인트

- [x] 전역상태관리를 사용해서 상태를 분리하고 관리했나요?
- [x] Props Drilling을 최소화했나요?
- [x] shared 공통 컴포넌트를 분리했나요?
- [x] shared 공통 로직을 분리했나요?
- [x] entities를 중심으로 type을 정의하고 model을 분리했나요?
- [x] entities를 중심으로 ui를 분리했나요?
- [x] entities를 중심으로 api를 분리했나요?
- [x] feature를 중심으로 사용자행동(이벤트 처리)를 분리했나요?
- [x] feature를 중심으로 ui를 분리했나요?
- [x] feature를 중심으로 api를 분리했나요?
- [x] widget을 중심으로 데이터를 재사용가능한 형태로 분리했나요?

### 심화과제

#### 목표: 서버상태관리 도구인 TanstackQuery를 이용하여 비동기코드를 선언적인 함수형 프로그래밍으로 작성하기

- TanstackQuery의 사용법에 대한 이해
- TanstackQuery를 이용한 비동기 코드 작성에 대한 이해
- 비동기 코드를 선언적인 함수형 프로그래밍으로 작성하는 방법에 대한 이해

#### 체크포인트

- [x] 모든 API 호출이 TanStack Query의 useQuery와 useMutation으로 대체되었는가?
- [x] 쿼리 키가 적절히 설정되었는가?
- [x] fetch와 useState가 아닌 선언적인 함수형 프로그래밍이 적절히 적용되었는가?
- [x] 캐싱과 리프레시 전략이 올바르게 구현되었는가?

## 과제 셀프회고

## 상태 관리 개선

### 과제에서 좋았던 부분

zustand를 처음 써봤습니다..
Zustand에서는 비동기 로직을 스토어 내부에 직접 통합할 수 있어, 상태 업데이트를 한 곳에서 관리할 수 있다는게 굉장히 인상적이였습니다..!

### 과제를 하면서 새롭게 알게된 점

처음에 댓글 부분을 `feature/comment-management` 폴더에 두고, 댓글 관련된 부분을 전부 넣었는데, 이후 `comment-add`, `comment-edit`으로 나누어 만들었습니다.

이런 관점에서 다른 기능들도 분리할 수 있다면 한 폴더 내에 관련한 기능들을 쉽게 찾을 수 있을 것 같았고,
다른 곳에서 재사용하기 좋다는 생각이 들었습니다.

항상 도메인 중심 방식을 추구했는데, 해당 기능이 다른 부분에서도 사용된다면 도메인에 종속적인 구조는 아쉬움이 있다는 점을 깨달았습니다.
FSD 아키텍처는 이런 문제를 해결하기 위한 좋은 접근법이었습니다.

또한 엔티티를 분류하는 과정에서 나만의 명확한 기준을 갖는 것이 중요하다는 점을 알게 되었습니다. 이는 팀 내의 일관성 있는 코드 구조를 유지하는 데 필수적이었습니다.

#### 나만의 기준 정립하기

엔티티 분류에 대한 개인적인 기준을 세우면서 다음과 같은 구체적인 판단 질문들을 정립했습니다

1. 이 개념이 데이터베이스에서 독립적인 테이블을 가지는가?
   대부분의 경우 DB 테이블과 일대일로 매핑되는 개념은 엔티티로 분류하는 것이 적합합니다.
   예: User 테이블은 entities/user로, Post 테이블은 entities/post로 분류했습니다.
   실제 적용: Comment 테이블이 있었기 때문에 entities/comment를 생성하고 여기에 기본 모델과 타입을 정의했습니다.
2. 이 개념이 API에서 독립적인 엔드포인트를 가지는가?
3. 이 개념이 다른 엔티티와의 관계에서 독립적으로 존재하는가?
   댓글은 게시물에 종속적이지만, 자체적으로도 관리되고 처리되므로 독립적인 엔티티로 간주했습니다.
   실제 적용: Comment와 Post는 관계가 있지만, 각각 독립적인 엔티티로 분리하고 관계는 타입과 API 함수에서 표현했습니다.
   -> 과제에 이 부분에 아쉬운 점이 있다면, "태그"도 독립적인 엔티티로 분리해도 괜찮았을 것 같다 라는 생각이 들었습니다.
4. 이 개념의 UI 표현이 독립적으로 재사용 가능한가?
   CommentItem, CommentList 등의 UI 컴포넌트가 여러 곳에서 재사용될 수 있다면, 이를 엔티티의 UI로 분리하는 것이 유리하지 않을까?

### 아쉬웠던 부분

컨디션 관리를 잘 하지 못해서 작은 목표를 세워서 작업했습니다. 처음에 분리했던 "댓글" 부분을 개선하는 데에 중점을 두어 작업을 하였습니다. 다른 부분을 신경쓰지 못한 부분이 너무 아쉽게 느껴집니다.
특히 게시물 목록과 필터링, dialog를 시간 제약으로 분리하지 못한게 굉장히 아쉬웠습니다.

### 과제를 진행하면서 아직 애매하게 잘 모르겠다 하는 점, 혹은 뭔가 잘 안되서 아쉬운 것들

1. **레이어 경계의 모호함**: 특히 `entities`와 `features` 간의 경계가 때로는 모호할 때가 있었습니다. 예를 들어, 댓글 좋아요 기능이 엔티티의 일부인지 아니면 별도의 기능인지 결정하는 것이 어려웠습니다.

2. **비동기 상태 관리 통합**: Zustand와 TanStack Query의 통합 방식에 대한 최적의 패턴을 찾기 어려웠습니다. 두 라이브러리를 함께 사용할 때의 베스트 프랙티스에 대한 더 많은 학습이 필요할 것 같습니다.

3. 쿼리키 무효화를 통해서 업데이트 하고 싶은 부분에 있어 아쉽다고 생각했습니다. 낙관적 업데이트가 필수인..게..

## 리뷰 받고 싶은 내용이나 궁금한 것에 대한 질문
